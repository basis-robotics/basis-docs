---
sidebar_position: 3
---

**CMake Primer for Building a C++ Project**

CMake is an open-source build system generator designed to manage the complexities of building software projects across multiple platforms. It simplifies the process of creating Makefiles or project files for different environments, making it a go-to solution for many C++ developers. In this primer, we'll walk you through the basics of using CMake for your C++ project.

### Getting Started with CMake

#### Prerequisites

- **CMake**: You need to have CMake installed on your system. You can download it from [cmake.org](https://cmake.org/download/) or install it through your platform's package manager.
- **C++ Compiler**: A C++ compiler like Clang should be installed and accessible in your system's PATH.

#### Directory Structure

CMake encourages an organized project structure. A common layout for a simple C++ project might look like this:

```
MyProject/
|-- CMakeLists.txt
|-- src/
|   |-- main.cpp
|-- include/
|   |-- MyHeader.h
|-- build/
```

- **CMakeLists.txt**: The main CMake configuration file.
- **src/**: Directory containing source files.
- **include/**: Directory containing header files.
- **build/**: Directory for building the project (recommended for out-of-source builds).

### Writing a CMakeLists.txt File

The core of using CMake is creating a **CMakeLists.txt** file that specifies how your project should be configured and built. Here is a basic example for a simple C++ project:

```cmake
cmake_minimum_required(VERSION 3.28)

# Set the project name and version
project(MyProject VERSION 1.0)

# Specify the C++ standard
set(CMAKE_CXX_STANDARD 20)
set(CMAKE_CXX_STANDARD_REQUIRED True)

# Add the executable
add_executable(MyProject src/main.cpp)

# Include header files
target_include_directories(MyProject PUBLIC include)
```

Let's break down what each part does:

- **cmake\_minimum\_required(VERSION 3.10)**: Specifies the minimum version of CMake required.
- **project(MyProject VERSION 1.0)**: Defines the project name and version.
- **set(CMAKE\_CXX\_STANDARD 20)**: Specifies the C++ standard to use (e.g., C++20).
- **add\_executable(MyProject src/main.cpp)**: Creates an executable target named `MyProject` using `main.cpp`.
- **target\_include\_directories(MyProject PUBLIC include)**: Tells CMake where to find the header files.

### Building Your Project

Once your **CMakeLists.txt** file is ready, you can build your project. It's recommended to use an out-of-source build, meaning you keep generated files separate from your source code.

1. **Create a Build Directory**
   ```sh
   mkdir build
   cd build
   ```
2. **Generate the Build Files**
   Run CMake to generate the necessary build files (e.g., Makefiles or Visual Studio project files):
   ```sh
   cmake ..
   ```
3. **Build the Project**
   Use the build tool generated by CMake (e.g., Make or Ninja):
   ```sh
   cmake --build .
   ```

### Handling Dependencies

CMake makes it easy to handle external dependencies. If you want to include external libraries, you can use **find\_package** or **FetchContent** to bring them into your project.

Example using **find\_package**:

```cmake
find_package(OpenSSL REQUIRED)
if(OpenSSL_FOUND)
    target_link_libraries(MyProject PUBLIC OpenSSL::SSL OpenSSL::Crypto)
endif()
```

This snippet finds the OpenSSL library and links it to your project if available.

### Basis Additional Features: `generate_unit` and `add_plugin`

CMake can also be extended with custom functions to automate specific tasks in your project. In the Basis framework, two useful functions are `generate_unit` and `add_plugin`.

#### `generate_unit`

The `generate_unit` function is used to automate the creation of units in the Basis framework. It takes a unit name and generates the necessary source, header, and template files for the unit. Specifically:

- The main source file (`<unit_name>.cpp`) is placed in the `src/` directory (only generated if it doesn't already exist, as it is meant to be edited by the user).
- Header files (`<unit_name>.h`) are placed in the `include/` directory (only generated if they don't already exist, as they are meant to be edited by the user).
- Example template files (`<unit_name>.example.cpp` and `<unit_name>.example.h`) are placed in the `template/` directory.
- Generated files such as `unit_base.cpp`, `unit_base.h`, and `create_unit.cpp` are placed in the `generated/` directory inside the build directory.

This function helps ensure that all required files are created consistently, reducing boilerplate and improving productivity. Additionally, it sets up the appropriate build targets for the unit, including linking dependencies and handling installation details. Additionally, it sets up the appropriate build targets for the unit, including linking dependencies and handling installation details. Additionally, it sets up the appropriate build targets for the unit, including linking dependencies and handling installation details.

#### `add_plugin`

The `add_plugin` function is used to add plugins to your project. Plugins in the Basis framework serve various purposes, such as transport (e.g., TCP) and serialization (e.g., Protocol Buffers, ROS Message). The function helps declare the plugin as a shared library and installs it in the appropriate directory. Plugins are loaded dynamically and are found by their type and name, which makes it easy to extend your project with additional functionality while maintaining a consistent structure.

These functions provide high-level automation, making it easier to manage the creation of units and plugins in larger projects, especially when working with complex modular systems.

### Best Practices

- **Out-of-Source Builds**: Always create a separate build directory. It keeps your source tree clean and makes it easy to start fresh if something goes wrong.
- **Modularize CMakeLists.txt**: For larger projects, consider breaking your CMake files into multiple **CMakeLists.txt** files in each subdirectory. This helps manage complexity.
- **Verbose Output**: You can use the `--verbose` flag during the build process to see what commands are being run by CMake.

### Summary

CMake is a powerful tool that streamlines building C++ projects across multiple platforms. By defining how your code should be compiled and linked in a **CMakeLists.txt** file, CMake abstracts away the complexities of managing platform-specific build tools. With a few simple commands, you can easily configure and build your C++ projects, making it an indispensable tool for any developer.

The additional features provided by the Basis framework, `generate_unit` and `add_plugin`, enhance CMake's capabilities by enabling high-level automation and simplifying the management of complex projects.
